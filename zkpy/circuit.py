import subprocess
import os
import uuid
from zkpy.ptau import PTau

GROTH = "groth16"
PLONK = "plonk"
FFLONK = "fflonk"

# These handle finding file paths of created files during circuit compilation
# assume output directory is same as working directory
# TODO: Might want to move these into their own utility file


def get_base(circ_file):
    return os.path.basename(circ_file).split('.')[0]


def get_r1cs_file(circ_file):
    return get_base(circ_file) + ".r1cs"


def get_sym_file(circ_file):
    return get_base(circ_file) + ".sym"


def get_js_dir(circ_file):
    return get_base(circ_file) + "_js"


def get_wasm_file(circ_file):
    return os.path.join(get_js_dir(circ_file), get_base(circ_file) + ".wasm")


def gen_rand_filename():
    return str(uuid.uuid4())


def gen_zkey_file():
    return gen_rand_filename() + ".zkey"


# TODO: Add checks if subprocess fails
# TODO: Add getters and setters
class Circuit:
    """
    Manages compiling, proving, and verifying Circom circuits.

    Args:
        circ_file (str): Path to a circom circuit file.
        output_dir (str, optional): Path to where generated files should be outputted. Defaults to the current directory.
        working_dir (str, optional): Path that all given file paths are relative to. Defaults to the current directory
        r1cs (str, optional): Optional path to a pre-generated r1cs file.
        sym_file (str, optional): Optional path to a pre-generated symbols file.
        js_dir (str, optional): Optional path to a pre-generated directory with JS files.
        wasm (str, optional): Optional path to a pre-generated wasm file.
        witness (str, optional): Optional path to a witness file.
        zkey (str, optional): Optional path to a pre-generated zkey file.
        vkey (str, optional): Optional path to a pre-generated verification key file.

    Attributes:
        circ_file (str): Path to a circom circuit file. This circuit can be compiled, proved, etc. with this class.
        output_dir (str): Path to where generated files will be outputted.
        working_dir (str): Specifies the path that all given file paths are relative to.
        r1cs_file (str): Path to an r1cs file. This can be generated by the class itself when a circuit is compiled, or the path can be given if already generated
        sym_file (str): Path to a symbols file. This can be generated by the class itself when a circuit is compiled, or the path can be given if already generated
        js_dir (str): Path to the JS directory generated by SnarkJS. This can be generated by the class itself when a circuit is compiled, or the path can be given if already generated
        wasm_file (str): Path to a wasm file. This can be generated by the class itself when a circuit is compiled, or the path can be given if already generated
        zkey (str): Path to a zkey file. This can be generated by the class itself when a circuit is compiled, or the path can be given if already generated
        vkey (str): Path to a verification key file. This can be generated by the class itself when a circuit is compiled, or the path can be given if already generated

    """

    def __init__(
        self,
        circ_file,
        output_dir="./",
        working_dir="./",
        r1cs=None,
        sym_file=None,
        js_dir=None,
        wasm=None,
        witness=None,
        zkey=None,
        vkey=None,
    ):
        self.circ_file = circ_file
        self.output_dir = output_dir
        self.working_dir = working_dir
        self.r1cs_file = r1cs
        self.sym_file = sym_file
        self.js_dir = js_dir
        self.wasm_file = wasm
        self.wtns_file = witness
        self.zkey_file = zkey
        self.vkey_file = vkey

    def compile(self):
        """Compiles the circuit and generates an r1cs file, a symbols file, a wasm file, and a js dir"""

        subprocess.run(
            ["circom", self.circ_file, "--r1cs", "--sym", "--wasm", '-o', self.output_dir],
            capture_output=True,
            cwd=self.working_dir,
        )
        self.r1cs_file = os.path.join(self.output_dir, get_r1cs_file(self.circ_file))
        self.sym_file = os.path.join(self.output_dir, get_sym_file(self.circ_file))
        self.wasm_file = os.path.join(self.output_dir, get_wasm_file(self.circ_file))
        self.js_dir = os.path.join(self.output_dir, get_js_dir(self.circ_file))

    # TODO: make sure compile was run first or files exist before continuing
    def get_info(self):
        """Prints info about the circuit. Requires that the circuit was compiled first."""
        proc = subprocess.run(
            ["snarkjs", "r1cs", "info", self.r1cs_file], capture_output=True, cwd=self.working_dir, check=True
        )
        print(proc.stdout.decode())

    def print_constraints(self):
        """Prints info about the constraints of the circuit. Requires that the circuit was compiled first."""
        proc = subprocess.run(
            ["snarkjs", "r1cs", "print", self.r1cs_file, self.sym_file],
            capture_output=True,
            cwd=self.working_dir,
            check=True,
        )
        print(proc.stdout.decode())

    # TODO: Export r1cs to json

    # TODO: handle filename conflict
    # Need to input an input.json file
    def gen_witness(self, input_file, output_file=None):
        """Generates a witness file. Requires that the circuit was compiled first.

        Args:
            input_file (str): Path to an input json file that specifies the inputs to the circuit.
            output_file (str): Path of where the witness file should be outputted. Defaults to a randomly generated file name.
        """
        if output_file is None:
            output_file = os.path.join(self.output_dir, "witness.wtns")
        if self.wasm_file is None and self.js_dir is not None:
            self.wasm_file = os.path.join(self.output_dir, get_wasm_file(self.circ_file))
        gen_wtns_file = os.path.join(self.js_dir, "generate_witness.js")
        proc = subprocess.run(
            ["node", gen_wtns_file, self.wasm_file, input_file, output_file],
            capture_output=True,
            cwd=self.working_dir,
            check=True,
        )
        print(proc.stdout.decode('utf-8'))
        print(proc.stderr.decode('utf-8'))
        self.wtns_file = output_file

    # Sets up to generate proof. Scheme = proving scheme, ptau = previous powers of tau ceremony
    def setup(self, scheme, ptau, output_file=None):
        """Prepares to generate proof and creates a zkey file.

        Args:
            scheme (str): The proving scheme to use. Can either be `GROTH`, `PLONK`, or `FFLONK`.
            ptau (PTau): A `PTau` object with a completed powers of tau ceremony.
            output_file (str): Path of where the zkey file should be outputted. Defaults to a randomly generated file name.
        """
        if output_file is None:
            output_file = os.path.join(self.output_dir, gen_zkey_file())
        # TODO: check scheme is either plonk, fflonk, or groth
        proc = subprocess.run(
            ["snarkjs", scheme, "setup", self.r1cs_file, ptau.ptau_file, output_file],
            capture_output=True,
            cwd=self.working_dir,
            check=True,
        )
        print(proc.stdout.decode('utf-8'))
        self.zkey_file = output_file

    def contribute_phase2(self, entropy="", output_file=None):
        """Contributes to phase 2. Required for the Groth16 proving scheme. The circuit must have been previously setup.

        Args:
            entropy (str): Random entropy to contribute to the zkey.
            output_file (str, optional): Path of where the zkey file should be outputted. Defaults to a randomly generated file name.
        """
        if output_file is None:
            output_file = os.path.join(self.output_dir, gen_zkey_file())
        proc = subprocess.run(
            [
                "snarkjs",
                "zkey",
                "contribute",
                self.zkey_file,
                output_file,
                "-v",
                f'-e={entropy}',
            ],
            capture_output=True,
            cwd=self.working_dir,
            check=True,
        )
        print(proc.stdout.decode('utf-8'))
        self.zkey_file = output_file

    def prove(self, scheme, proof_out=None, public_out=None):
        """Generates a proof for the circuit.

        Args:
            scheme (str): The proving scheme to use. Can either be `GROTH`, `PLONK`, or `FFLONK`.
            proof_out (str, optional): Path of where the proof file should be outputted. Defaults to 'proof.json'.
            public_out (str, optional): Path of where the public file should be outputted. Defaults to 'public.json'.
        """
        if proof_out is None:
            proof_out = os.path.join(self.output_dir, "proof.json")
        if public_out is None:
            public_out = os.path.join(self.output_dir, "public.json")
        proc = subprocess.run(
            ["snarkjs", scheme, "prove", self.zkey_file, self.wtns_file, proof_out, public_out],
            capture_output=True,
            cwd=self.working_dir,
            check=True,
        )
        self.proof_file = proof_out
        self.public_file = public_out
        print(proc.stdout.decode('utf-8'))

    def verify_zkey(self, ptau, zkey_file=None):
        """Verifies a zkey is valid.

        Args:
            ptau (PTau): A powers of tau ceremony.
            zkey_file (str, optional): Path to the zkey file to verify. Defaults to a previously generated zkey.
        """
        if zkey_file is None:
            zkey_file = self.zkey_file
        proc = subprocess.run(
            ["snarkjs", "zkey", "verify", self.r1cs_file, ptau.ptau_file, zkey_file],
            capture_output=True,
            cwd=self.working_dir,
            check=True,
        )
        print(proc.stdout.decode('utf-8'))
        if proc.stderr:
            return False
        else:
            return True

    def export_vkey(self, zkey_file=None, output_file=None):
        """Exports a verification key.

        Args:
            zkey_file (str, optional): Path to a zkey file from which the verification key should be created. Defaults to a previously generated zkey.
            output_file (str, optional): Path to where the verification key file should be outputted. Defaults to a randomly generated file name.
        """
        if zkey_file is None:
            zkey_file = self.zkey_file
        if output_file is None:
            output_file = os.path.join(self.output_dir, gen_rand_filename() + '.json')
        subprocess.run(
            ["snarkjs", "zkey", "export", "verificationkey", zkey_file, output_file],
            capture_output=True,
            cwd=self.working_dir,
            check=True,
        )
        self.vkey_file = output_file

    def verify(self, scheme, vkey_file=None, public_file=None, proof_file=None):
        """Verifies that a proof is valid.

        Args:
            vkey_file (str, optional): Path to a verification key file. Defaults to a previously generated vkey.
            public_file (str, optional): Path to a public file. Defaults to a previously generated public_file.
            proof_file (str, optional): Path to the proof. Defaults to a previously generated proof.

        Returns:
            bool: Whether the proof is valid or not.
        """
        if vkey_file is None:
            vkey_file = self.vkey_file
        if public_file is None:
            public_file = self.public_file
        if proof_file is None:
            proof_file = self.proof_file
        proc = subprocess.run(
            ["snarkjs", scheme, "verify", vkey_file, public_file, proof_file],
            capture_output=True,
            cwd=self.working_dir,
            check=True,
        )
        print(proc.stdout.decode('utf-8'))
        if proc.stderr:
            return False
        else:
            return True

    # TODO: Create a convenience function that handles compilation, setup, witness gen, and powers of tau for a circuit


if __name__ == "__main__":
    ptau = PTau(working_dir="./tmp")
    print("Starting powers of tau")
    ptau.start()
    print("Contribute")
    ptau.contribute()
    print("Beacon")
    ptau.beacon()
    print("Phase2")
    ptau.prep_phase2()
    print("Verify")
    ptau.verify()
    print(ptau.ptau_file)

    circuit = Circuit("./example_circuits/circom.circom", output_dir="./tmp")
    circuit.compile()
    circuit.get_info()
    circuit.print_constraints()
    circuit.gen_witness("./example_circuits/input.json")
    circuit.setup("plonk", ptau)
    circuit.prove("plonk")
    circuit.export_vkey()
    circuit.verify("plonk")
